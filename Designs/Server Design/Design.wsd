@startuml ClassDiagram
Title Class Diagram

Class Communication
{
    {method} + [[noreturn]] void Run()
    {method} + void Stop()
}

' using Event_function_t = void();
interface IClusterConnection
{
    {field} - Event_function_t onMessageHandler
    {method} + [[noreturn]] void Run()
    {method} + void Stop()
    {method} + void Broadcast(IMessage message)
    ' {method} + void Send(IMessage message, IPAdress myip)
    {method} + void SetOnMessageHandler(Event_function_t handler)
}

note bottom of IClusterConnection
using Event_function_t = void();
end note

    {field} - int: port
    {field} - IPAddress: myip
    {field} - IPAddress<vector>: clients
    {field} - char[1024]: buffer
    ' change char array to string?
    ' {method} + void SetPort(int port)
    {method} + int GetPort()
    ' {method} + void setIP(IPAdress IP)
    {method} + IPAdress GetmyIP()
    {method} + IPAddress<vector> GetClients()
    {method} + Communication(int port, IPAddress ip)
    {method} + void Listen(int port)
    {method} + void Send()
    {method} + void Broadcast()
    {method} + bool Connect()
    {method} + bool IsConnected()
    {method} + bool CloseConnection()
}

Class PlainFileDatabase
{
    {field} - std::string: path
    {method} + Database(std::string path)
    {method} + void Add(Object object)
    {method} + void Remove(Object object)
    {method} + bool SearchIfPresent(Object object)
}

Class Object
{
    {field} - string: name
    {field} - int: id
    ' {field} - string type
    {method} + void SetName(string name)
    {method} + string GetName()
    {method} + void SetId(int id)
    {method} + int GetPort()
    ' {method} + void SetType(string type)
    ' {method} + string GetType()
    -- functions & methods --
    {method} + Object(string name, int id)
    {method} + string ToString(Object Object)
}

enum MessageType
{
    SERVER_REQUEST_PRODUCT,
    NODE_RESPOND_TO_PRODUCT_REQUEST,
    NODE_EVENT_PRODUCT_FOUND,
    NODE_SIGN_IN,
    NODE_SIGN_IN_RESPONSE,
    NODE_NOTIFY_NEW_PRODUCT,
    NODE_NOTIFY_NEW_PRODUCT_RESPONSE,
    HEARTBEAT,
    HEARTBEAT_RESPONSE,
}

interface IMessage
{
    {field} - IMessageType: type
    {method} + IMessageType GetType()
}

note bottom of IMessage
Each MessageType has its own class.
They are not listed here because it would create clutter.
end note

interface IProtocolParser
{
    {method} + IMessage Parse(std::string data)
    {method} + std::string Interpret(IMessage data)
}

Class JSONProtocolParser
{
    {method} + JSONProtocolParser()
}

Class UserInterface
{
    {method} + UserInterface(mutex mutex)
    {method} + void Terminal()
    {method} + string Read()
    {method} + void Write(string input)
}

Class Main
{
    {field} - mutex: mutex
    {field} - UserInterface: terminal
    {method} + void Main()
}

Main "1" *-- "1" PlainFileDatabase

' EMPTY CLASSES
' END OF EMPYY CLASSES

Main -o UserInterface
Main o-- Object
Main -- Database
Main -- Communication
Main *-- IMessage
Communication o-- IMessage
IProtocolParser <|.. JSONProtocolParser
IProtocolParser - IMessage
Communication o-- IProtocolParser

' Controller "1" o-- "1" WiFiHandler
' Controller "1" o-- "1" IMasterSlave
' Controller "1" o-- "1" JsonBuilder
' Controller "1" o-down- "1" IDipSwitch
' Controller "1" o-- "1" WebSocketHandler

' WiFiHandler "1" o-- "1" WiFiData
' WebSocketHandler "1" o-- "1" WebsocketData

' See if we should separate WebSocket & WiFi
' object opslaan als JSON objecten?
@enduml